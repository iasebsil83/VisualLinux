t0 Visual Linux




t1 Overview

p \iVisual Linux\i is a graphical simulation application showing how the Linux kernel execution works. \
This simulator includes memory usage in CPU cache, control flow between user and kernel code, exception handling and more.
b


t2 Disclaimer on exactness

p This application shows \ba \cff0000simplified\c representation\b of the Linux kernel mechanisms. \
These are not exactly what the Linux kernel code does. \
The CPU instruction set is completely fictive as well as the long term storage use. \
We mostly concentrates on execution & short term memory management between kernel and user "code".

p Also, for more simplicity, CPU is the only interface with hardware in this simulation program. \
Operations such as printing text or accessing to long term storage are assumed by the CPU instead of using other devices. \
Another thing that you might find weird in this implementation is that we only use one type of memory block : words of 2 bytes (16b). \
This has also been made to simplify representations and reduce display information.

l This project has been made for educational purpose only.


t2 How does it work

p To simulate kernel loading and boot sequence, \iVisualLinux\i will require to have a kind of "hard drive" \
represented by a directory given when executing the program. \
In this directory, a file \mkernel.hc\m must exist. \
It is the main program (and also the first one) that will be executed.

p Other programs which are \buser\b programs can be executed afterwards. \
When the (virtual) kernel will access to its "long term storage" to load a user program, it will look in that same storage directory \
for the corresponding \m.uc\m file to load. \
Therefore, you are completely free to create as much user programs as you want. \
Note that the file is written under an "UC" syntax : \
this action is similar to writting directly compiled ELF code onto disk so a specific synatx must be respected.

p The syntaxes used in that project are very specific (and simplified to be understood). \
Full descriptions are available below but you may not need to learn them to use \i\i at first. \
Infact, before trying to do things yourself, some examples have already been made ready-to-use in the \mstorage/\m directory. \
You better run them first and then, if curious, dig into the code to make yours.




t1 Use

t2 Requirements

l This program has been made to run on GNU/Linux operating systems.

p If you already have the compiled \iVisualLinux\i application on your computer, nothing else is required. \
However, to compile this project you will require package \mfreeglut3-dev\m.
" bash
sudo apt install freeglut3-dev #on apt based distros
"


t2 Compile & Run

l To compile \iVisual Linux\i :
" bash
bld/build
"
l The resulted application should be available under \mapp/VisualLinux\m.

l To execute \iVisual Linux\i :
" bash
app/VisualLinux <storage_dir> #example: "app/VisualLinux storage/example1/"
"
l Enjoy using the examples given in the \mstorage/\m directory.

l The next chapter is about how to make your own kernel and user codes yourself, so you can skip it if not interrested.




t1 We need to go deeper

t2 HC and UC

p As said before, the CPU instruction set is completely custom. \
As the CPU is the only interface we use for hardware interactions, I invented the \bHC\b syntax (= "Hardware Code") for the occasion \
which is nothing more than CPU instructions directly written in a file, one instruction per line. \
This syntax is highly restrictive making things easy for our "virtual CPU" to operate.

p However, you may know that the format we use in executable files for Linux kernel on disk (basically ELF) \
is not meant to directly operate with hardware but it is loaded into memory under a slightly different format to then, be correctly used by hardware. \
The kernel does some stuff to turn something written \uby\u "users" \ufor\u the kernel into something \ufor\u the hardware itself.

p For this reason, I also decided to make a user executable code syntax (in analogy with ELF, DWARF...) : the \bUC\b syntax (= "User Code"). \
This is the format that \bMUST\b be used in user programs to be correctly loaded \uby\u the kernel into HC format. \
(Note that at the end, everything will become HC since it is the only syntax that the CPU understands).


t2 HC in details

p HC is consists in a list of instructions, each composed of 4 bytes (32 bits). \
Each instruction is composed of some indentification information and a value parameter. \
Here is what is inside an HC instruction exactly :

p The first bit is the \umode\u of that instruction, 0:user, 1:kernel. \
Then another individual bit gives the information whether the following parameter will concern \
a literal value (0) or rather target a register (1). \
The next 14 bits are used to give the instruction ID (explained a few paragraphs below). \
Finally, as you might have guessed, the remaining 16 bits forms the parameter value to be used with that instruction.

p There is no separator between HC instructions, an HC file must only contain a multiple of 4 bytes, \
each block considered as an HC instruction. \
Here is the list of all HC instruction IDs with their explanation :
- ID:0, \uAddition\u
Perform an \bAddition\b between registers R0000 and given parameter and write result into R0000. \
If parameter is a value (not register), use it as an address to get value from RAM.
-
- ID:1, \uMultiplication\u
Perform a \bMultiplication\b between registers R0000 and given parameter and write result into R0000. \
If parameter is a value (not register), use it as an address to get value from RAM.
-
- ID:2, \uPrint\u
\bPrint\b onto virtual screen the 0-terminated string in RAM at the address given as parameter. \
If parameter is a register, use the value stored in that register as RAM address.
-
- ID:3, \uJump\u
\bJump\b to the instruction index given. \
-
- ID:4, \uInput\u to current stack
\bInput\b the given value to current stack.
-
- ID:5, \uOutput\u to current stack
\bOutput\b the last value from current stack into the given destination. \
If parameter is a value (not register), use it as address to store result into memory.
-
- ID:6, Write from \uMemory\u (RAM)
Write value stored in \bMemory\b (RAM) at the address stored in R0000 into the given destination. \
If parameter is a value (not register), use it as another address to store result into memory.
-
- ID:7, Write from current \uRegisters\u
Write value from \bRegister\b at address stored in R0000 into the given destination. \
If parameter is a value (not register), use it as an address to store result into memory. \
Using this instruction with parameter R0000 is possible (but useless).
-
- ID:8, \uLoad\u from storage
\bL\boad an external HC program into RAM at the address (offset) given as parameter. \
The filename of the program to load will be taken from RAM at the address set in R000 and must be 0-terminated.
-
- ID:9, \uZero\u
Fill the given number of words in RAM with \bZ\beros starting from the address stored in R0000.
-
- ID:10, \bC\bhange CPU Memory
\bC\bhange CPU memory to the given index.
-


t2 UC in details

p TODO


t2 Producing kernel code

p As said before, the kernel code is the main and first program that will be used in our computer (simulator). \
The thing is that we can't use UC syntax to load it (can't load himself since he is not here). \
So we must have an "already loaded" HC syntax to give to \iVisualLinux\i so that it can barely execute the kernel code without operating anything else.

p The thing is that the kernel code is not that simple to write and can be pretty big \
so writing it directly in HC syntax becomes quickly unfair and unmaintainable. \
For this reason, when compiling \iVisualLinux\i, another program is produced alongside the main application : \mUC2kHC\m. \
This program allows you to compile a UC file into an HC one as a "regular" kernel will have done, \
\cff0000\bexcept that\b\c resulted instruction will not be set in "user" mode but in "kernel" mode.

p Here is an example of how to produce its own kernel code :
" bash
#write my own kernel in regular UC
mkdir storage/myCustomOS
nano  storage/myCustomOS/kernel.uc

#compile it into HC with kernel mode: 'k'
app/UC2HC k storage/myCustomOS/kernel.uc > storage/myCustomOS/kernel.hc

#use the generated "kernel.hc" file
app/VisualLinux storage/myCustomOS
"
l There you go !

b

l You should have everything you need to work with \iVisual Linux\i, enjoy !

b
b

l Contact    : \li.a.sebsil83@gmail.com\l\l
l Youtube    : \lhttps://www.youtube.com/user/IAsebsil83\l\l
l Repository : \lhttps://github.com/iasebsil83\l\l

l Let's Code !\arBy I.A.
